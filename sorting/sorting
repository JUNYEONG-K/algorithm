정렬이란 데이터를 특정 기준에 따라 순서대로 나열하는 것
데이터 개수 적을 때, 혹은 많지만 범위가 한정되어 있을 때, 혹은 이미 정렬되어 있을 때

7, 5, 9, 0, 3, 1, 6, 2, 4, 8 => how to sort?


a. 선택 정렬
처리되지 않은 데이터 중에서 가장 작은 데이터를 선택해, 맨 앞에 있는 데이터와 바꾸는 작업 반복
    1. 7, 0 change
    0, 5, 9 , 7, 3, ...

    2. 5 ~ 8 : 5, 1 change
    0, 1, 9, 7, 3, ...

    3. 9 ~ 8 : 9, 2 change
    0, 1, 2, 7, 3, ...

    4. 7 ~ 8 : 7, 3 change
    0, 1, 2, 3, 7, ...
탐색 범위는 점점 줄어들고, 매번 모든 데이터 뒤져야함 (최소값 찾기 위해)

시간 복잡도 = O(N^2) (N번만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 한다.)


b. 삽입 정렬
처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입한다.
선택정렬 보다 구현 난이도는 높지만, 더 효율적 !
    1. 첫번째 데이터인 7은 이미 정렬되어 있다고 가정하고, 두번 째 데이터인 5가 삽입될 위치 결정 (7의 왼쪽 혹은 오른쪽)
    5, 7, 9, 0, ...

    2. 9가 들어갈 위치 결정 (5,7 기준)
    5, 7, 9, ...

    3. 0이 들어갈 위치 결정 (5, 7, 9 기준)
    0, 5, 7, 9, ...

    4. 3이 들어갈 위치 결정 (0, 5, 7, 9 기준)
    0, 3, 5, 7, 9, ...
시간 복잡도 = O(N^2)
현재 리스트의 데이터가 거의 정렬되어 있는 경우라면 매우 빠르게 동작됨 (최선의 경우 O(N) 복잡도)

c. 퀵 정렬
기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법
일반적인 상황에서 가장 많이 사용되는 정렬 알고리즘 중 하나
병합 정렬과 더불어 대부분의 프로그래밍 언어의 표준 정렬 라이브러리의 근간이 되는 알고리즘
가장 기본적인 퀵 정렬은 첫 번째 데이터를 기준 데이터(pivot)로 설정한다.
    1. pivot 을 기준으로, 왼쪽에서부터는 pivot 보다 큰 값을, 오른쪽에서부터는 pivot 보다 작은 값을 선택하여 서로 위치를 바꿔줌
    2. 왼쪽에서부터의 pivot 보다 큰 값을 찾고, 오른쪽에서부터 pivot 보다 작은 값을 찾았을 때, 만약 이 둘의 위치가 엇갈린 경우라면
        그 중 작은 값을 pivot 과 바꾼다.
    3. 그러면 pivot 을 기준으로, 왼쪽 파트와 오른쪽 파트로 분할 (divide) 된다.
    4. 각 파트에 대해 첫 원소를 pivot 으로 설정하여 퀵 정렬 다시~~ (재귀)
시간 복잡도 = O(NlogN) (평균) (분할이 절반에 가까울 수록 좋음)
하지만 최악의 경우 O(N^2) (분할이 한쪽에 편향되어 있는 경우) like 이미 정렬된 배열
표준 라이브러리에서는 최악의 경우에도 NlogN 의 시간복잡도가 나올 수 있도록 알고리즘을 설정해뒀으니 걱정 ㄴㄴ

d. 계수 정렬
특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠르게 동작하는 정렬 알고리즘
데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때 사용 가능
데이터의 개수가 N, 데이터(양수) 중 최대값이 K일 때 최악의 경우에도 수행시간 O(N+K) 보장
    1. 가장 작은 데이터부터 가장 큰 데이터까지의 범위가 모두 담길 수 있는 리스트 생성
    if data = 7 5 9 0 3 1 6 2 9 1 4 8 0 5 2:
        list => index 0~9 (각 인덱스는 데이터에 해당함, 즉 각 데이터가 몇개씩 있는지 count 할 리스트를 생성하는 것!)
    2. 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가시킨다.
    3. 최종적으로 리스트에는 각 데이터가 몇번씩 등장했는지 그 횟수가 기록됨.
    4. 결과를 확인할 때는 리스트의 첫번째 데이터부터 하나씩 그 값만큼 반복하여 인덱스를 출력한다.
상대적으로 공간 복잡도가 높음 (리스트 생성 시 메모리 상대적으로 쪼끔 많이 사용)
동일한 값을 가지는 데이터가 여러 개 등장할 때 효과적으로 사용가능!
if 데이터가 0과 999,999 단 2개만 존재하는 경우,,, count 배열을 1,000,000 개 만들어야 함;;;


e. 버블 정렬
인접한 두 수를 비교해가며, 큰 수를 뒤로 보내, 최종적으로 맨 뒤가 가장 큰 값을 가지도록 완성
이후 이 작업을 계속 반복
시간 복잡도 = O(N^2)


f. 병합 정렬 (Merge Sort)
시간 복잡도 = O(NlogN)
[1,4] & [2,3] merge =>
    1. 1, 2 비교 => [1]
    2. 4, 2 비교 => [1,2]
    3. 4, 3 비교 => [1,2,3]
    4. 남은 4 선택 => [1,2,3,4]


파이썬의 경우, 기본 sort 메서드는 병합정렬을 기반으로 하는 하이브리드 알고리즘을 사용함.